<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BrailleBridge API + WebSocket Contract</title>

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #0f1620;
      --panel2: #101b27;
      --text: #e6edf3;
      --muted: #9fb0c0;
      --border: rgba(255,255,255,.10);
      --accent: #6aa6ff;
      --accent2: #7ee787;
      --danger: #ff6b6b;
      --warn: #ffd166;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    /* Light theme override */
    [data-theme="light"] {
      --bg: #f6f8fb;
      --panel: #ffffff;
      --panel2: #fbfcfe;
      --text: #0b1220;
      --muted: #4b5a6a;
      --border: rgba(10,20,40,.12);
      --accent: #2563eb;
      --accent2: #16a34a;
      --danger: #dc2626;
      --warn: #b45309;
      --shadow: 0 10px 30px rgba(0,0,0,.10);
    }

    /* Auto dark based on OS, unless user picked explicit theme */
    @media (prefers-color-scheme: light) {
      :root:not([data-theme]) {
        --bg: #f6f8fb;
        --panel: #ffffff;
        --panel2: #fbfcfe;
        --text: #0b1220;
        --muted: #4b5a6a;
        --border: rgba(10,20,40,.12);
        --accent: #2563eb;
        --accent2: #16a34a;
        --danger: #dc2626;
        --warn: #b45309;
        --shadow: 0 10px 30px rgba(0,0,0,.10);
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 15% 10%, rgba(106,166,255,.10), transparent 60%),
                  radial-gradient(900px 650px at 90% 25%, rgba(126,231,135,.10), transparent 55%),
                  var(--bg);
      color: var(--text);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(10px);
      background: color-mix(in oklab, var(--bg) 80%, transparent);
      border-bottom: 1px solid var(--border);
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 18px;
    }

    .topbar {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    .title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title h1 {
      font-size: 18px;
      margin: 0;
      letter-spacing: .2px;
    }

    .title .sub {
      font-size: 13px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      appearance: none;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, color-mix(in oklab, var(--panel) 92%, white 8%), var(--panel));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: var(--shadow);
      font-size: 13px;
      line-height: 1;
      min-height: 38px;
      transition: transform .06s ease, border-color .15s ease;
    }
    a.btn { text-decoration: none; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: color-mix(in oklab, var(--accent) 60%, var(--border)); }
    .btn.good { border-color: color-mix(in oklab, var(--accent2) 60%, var(--border)); }
    .btn.danger { border-color: color-mix(in oklab, var(--danger) 55%, var(--border)); }
    .btn.ghost { background: transparent; box-shadow: none; }

    main .wrap { padding-top: 16px; padding-bottom: 24px; }

    .grid {
      display: grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }

    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .hd {
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
    }

    .card .hd h2 {
      font-size: 14px;
      margin: 0;
      letter-spacing: .2px;
    }

    .card .hd .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      font-family: var(--mono);
    }

    .card .bd { padding: 14px; }

    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input[type="text"], textarea, select {
      width: 100%;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel) 92%, black 8%);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      outline: none;
      font-family: var(--mono);
    }

    textarea { min-height: 100px; resize: vertical; }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 560px) {
      .row { grid-template-columns: 1fr; }
    }

    .inline {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      font-family: var(--mono);
      user-select: none;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--danger) 18%, transparent);
    }
    .dot.ok {
      background: var(--accent2);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent2) 18%, transparent);
    }
    .dot.warn {
      background: var(--warn);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--warn) 18%, transparent);
    }

    .log {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in oklab, var(--panel) 94%, black 6%);
      padding: 10px;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      min-height: 220px;
      max-height: 560px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .log .line { white-space: pre-wrap; }
    .log .ts { font-size: 10px; color: var(--muted); }

    .kpi {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .kpi .box {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      background: color-mix(in oklab, var(--panel2) 85%, transparent);
    }
    .kpi .box .v {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
    }

    .split {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    code.badge {
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel2) 70%, transparent);
      color: var(--text);
    }

    .warn {
      color: var(--warn);
      font-family: var(--mono);
      font-size: 12px;
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <div class="topbar">
        <div class="title">
          <h1>BrailleBridge API + WebSocket Contract</h1>
          <div class="sub">
            HTTP: <span id="httpBaseLabel"></span> · WS: <span id="wsBaseLabel"></span>
          </div>
        </div>

        <div class="actions">
          <button class="btn" id="themeBtn" title="Toggle theme">Toggle theme</button>
          <a class="btn" href="braillebridge.html" title="Open BrailleBridge page">BrailleBridge page</a>
          <a class="btn" href="braillebridge://" title="Open BrailleBridge">Open BrailleBridge</a>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div class="grid">

        <!-- Left: HTTP controls -->
        <section class="card">
          <div class="hd">
            <div>
              <h2>HTTP API</h2>
              <div class="hint"></div>
            </div>
            <div class="pill">
              <span>HTTP status</span>
              <span class="dot" id="httpDot"></span>
              <span id="httpStatusText">unknown</span>
            </div>
          </div>

          <div class="bd">
            <div class="row">
              <div>
                <label for="httpBase">HTTP Base URL</label>
                <input id="httpBase" type="text" value="http://localhost:5000" />
              </div>
              <div>
                <label for="wsBase">WebSocket URL</label>
                <input id="wsBase" type="text" value="ws://localhost:5000/ws" />
              </div>
            </div>

            <div style="margin-top:12px;">
              <label for="brailleTextValue">Legacy braille text (POST /braille)</label>
              <div class="row">
                <div>
                  <label for="brailleTextValue">Text</label>
                  <input id="brailleTextValue" type="text" value="aap Aap AAP 123" />
                </div>
                <div class="inline" style="align-items:flex-end;">
                  <button class="btn primary" id="postBrailleBtn">POST /braille</button>
                </div>
              </div>
            </div>

            <div class="inline" style="margin-top:10px;">
              <button class="btn" id="getPingBtn">GET /ping</button>
              <button class="btn danger" id="getClearBtn">GET /clear</button>
              <button class="btn" id="getDevicesBtn">GET /devices</button>
              <button class="btn" id="getActiveDeviceBtn">GET /devices/active</button>
              <button class="btn" id="getTablesBtn">GET /tables</button>
            </div>

            <div class="kpi">
              <div class="box">
                <div><strong>Last HTTP response</strong></div>
                <div class="v" id="lastHttpResp">—</div>
              </div>
              <div class="box">
                <div><strong>Last HTTP error</strong></div>
                <div class="v" id="lastHttpErr">—</div>
              </div>
            </div>


          </div>
        </section>

        <!-- Right: WebSocket + Log -->
        <section class="card">
          <div class="hd">
            <div>
              <h2>WebSocket (SSoC)</h2>
              <div class="hint"></div>
            </div>
            <div class="inline">
              <div class="pill">
                <span>WS</span>
                <span class="dot" id="wsDot"></span>
              </div>
              <div class="pill">
                <span>Editor mode</span>
                <span class="dot" id="editorModeDot"></span>
              </div>
            </div>
          </div>

          <div class="bd">
            <div class="inline">
              <button class="btn good" id="wsConnectBtn">Connect</button>
              <button class="btn danger" id="wsDisconnectBtn">Disconnect</button>
              <button class="btn" id="wsSendModeBtn">Enable editorMode</button>
              <button class="btn danger" id="wsSendModeDisableBtn">Disable editorMode</button>
              <button class="btn" id="wsSendBackspaceBtn">Send Backspace</button>
              <button class="btn" id="wsSendSpaceBtn">Send Space</button>
              <button class="btn" id="wsSendEnterBtn">Send Enter</button>
            </div>

            <div class="row" style="margin-top:12px;">
              <div>
                <label for="wsTextValue">Text to send (editorInput)</label>
                <input id="wsTextValue" type="text" value="aap Aap AAP 123 ,.?"></input>
              </div>
              <div class="inline" style="align-items:flex-end;">
                <button class="btn" id="wsSendInputBtn">Send Text</button>
              </div>
            </div>


          </div>
        </section>

        <!-- Right: Latest brailleLine -->
        <section class="card">
          <div class="hd">
            <div>
              <h2>Latest brailleLine</h2>
              <div class="hint">Rendered from incoming WS message</div>
            </div>
            <div class="pill">
              <span>WS</span>
              <span class="dot ok"></span>
              <span>brailleLine</span>
            </div>
          </div>
          <div class="bd">
            <div class="split">
              <div>
                <label for="brailleUnicode">Braille UnicodeText</label>
                <textarea id="brailleUnicode" readonly></textarea>
              </div>
              <div class="row">
                <div>
                  <label for="brailleTable">Table</label>
                  <input id="brailleTable" type="text" readonly />
                </div>
                <div>
                  <label for="brailleTimestamp">TimestampUtc</label>
                  <input id="brailleTimestamp" type="text" readonly />
                </div>
              </div>
              <div>
                <label for="brailleSourceText">SourceText</label>
                <textarea id="brailleSourceText" readonly></textarea>
              </div>
            </div>
          </div>
        </section>

        <!-- Right: Latest cursorContext -->
        <section class="card">
          <div class="hd">
            <div>
              <h2>Latest cursorContext</h2>
              <div class="hint">Rendered from incoming WS message</div>
            </div>
            <div class="pill">
              <span>WS</span>
              <span class="dot ok"></span>
              <span>cursorContext</span>
            </div>
          </div>
          <div class="bd">
            <div class="split">
              <div class="row">
                <div>
                  <label for="cursorCellIndex">Cursor CellIndex</label>
                  <input id="cursorCellIndex" type="text" readonly />
                </div>
                <div>
                  <label for="cursorTextIndex">Cursor TextIndex</label>
                  <input id="cursorTextIndex" type="text" readonly />
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="cursorCharacter">Character</label>
                  <input id="cursorCharacter" type="text" readonly />
                </div>
                <div>
                  <label for="cursorWord">Word</label>
                  <input id="cursorWord" type="text" readonly />
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="cursorCellChar">Braille CellChar</label>
                  <input id="cursorCellChar" type="text" readonly />
                </div>
                <div>
                  <label for="cursorCellCodePoint">CellCodePoint</label>
                  <input id="cursorCellCodePoint" type="text" readonly />
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="cursorTable">Table</label>
                  <input id="cursorTable" type="text" readonly />
                </div>
                <div>
                  <label for="cursorTimestamp">TimestampUtc</label>
                  <input id="cursorTimestamp" type="text" readonly />
                </div>
              </div>
              <div>
                <label for="cursorSourceText">SourceText</label>
                <textarea id="cursorSourceText" readonly></textarea>
              </div>
            </div>
          </div>
        </section>

      </div>

      <section class="card" style="margin-top:14px;">
        <div class="hd">
          <div>
            <h2>Log</h2>
            <div class="hint">Incoming events (JSON)</div>
          </div>
          <div class="inline">
            <button class="btn" id="copyLogBtn" title="Copy log to clipboard">Copy log</button>
            <button class="btn danger" id="clearLogBtn" title="Clear log">Clear log</button>
            <div class="pill">
              <span>Log</span>
              <span class="dot ok"></span>
              <span>active</span>
            </div>
          </div>
        </div>
        <div class="bd">
          <div class="log" id="log"></div>
        </div>
      </section>
    </div>
  </main>

  <script>
    (function () {
      const el = (id) => document.getElementById(id);

      // Elements
      const httpBase = el("httpBase");
      const wsBase = el("wsBase");
      const httpBaseLabel = el("httpBaseLabel");
      const wsBaseLabel = el("wsBaseLabel");

      const brailleTextValue = el("brailleTextValue");
      const postBrailleBtn = el("postBrailleBtn");
      const getPingBtn = el("getPingBtn");
      const getClearBtn = el("getClearBtn");
      const getDevicesBtn = el("getDevicesBtn");
      const getActiveDeviceBtn = el("getActiveDeviceBtn");
      const getTablesBtn = el("getTablesBtn");

      const httpDot = el("httpDot");
      const httpStatusText = el("httpStatusText");
      const lastHttpResp = el("lastHttpResp");
      const lastHttpErr = el("lastHttpErr");

      const wsDot = el("wsDot");
      const wsStatusText = el("wsStatusText");
      const wsConnectBtn = el("wsConnectBtn");
      const wsDisconnectBtn = el("wsDisconnectBtn");
      const wsSendInputBtn = el("wsSendInputBtn");
      const wsTextValue = el("wsTextValue");
      const wsSendModeBtn = el("wsSendModeBtn");
      const wsSendModeDisableBtn = el("wsSendModeDisableBtn");
      const wsSendBackspaceBtn = el("wsSendBackspaceBtn");
      const wsSendSpaceBtn = el("wsSendSpaceBtn");
      const wsSendEnterBtn = el("wsSendEnterBtn");
      const editorModeDot = el("editorModeDot");
      const editorModeText = el("editorModeText");

      const brailleUnicode = el("brailleUnicode");
      const brailleTable = el("brailleTable");
      const brailleTimestamp = el("brailleTimestamp");
      const brailleSourceText = el("brailleSourceText");

      const cursorCellIndex = el("cursorCellIndex");
      const cursorTextIndex = el("cursorTextIndex");
      const cursorCharacter = el("cursorCharacter");
      const cursorWord = el("cursorWord");
      const cursorCellChar = el("cursorCellChar");
      const cursorCellCodePoint = el("cursorCellCodePoint");
      const cursorTable = el("cursorTable");
      const cursorTimestamp = el("cursorTimestamp");
      const cursorSourceText = el("cursorSourceText");

      const log = el("log");
      const themeBtn = el("themeBtn");
      const copyLogBtn = el("copyLogBtn");
      const clearLogBtn = el("clearLogBtn");

      // Theme
      function applyTheme(theme) {
        if (!theme) {
          document.documentElement.removeAttribute("data-theme");
          localStorage.removeItem("bb_theme");
          return;
        }
        document.documentElement.setAttribute("data-theme", theme);
        localStorage.setItem("bb_theme", theme);
      }
      function toggleTheme() {
        const cur = document.documentElement.getAttribute("data-theme");
        // If not set explicitly, infer current and toggle
        if (!cur) {
          const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          applyTheme(prefersLight ? "dark" : "light");
          return;
        }
        applyTheme(cur === "dark" ? "light" : "dark");
      }
      applyTheme(localStorage.getItem("bb_theme"));
      themeBtn.addEventListener("click", toggleTheme);

      // Log helpers
      function nowTs() {
        const d = new Date();
        const yy = String(d.getFullYear()).slice(-2);
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        const hh = String(d.getHours()).padStart(2, "0");
        const mi = String(d.getMinutes()).padStart(2, "0");
        return `${dd}.${mm}.${yy} ${hh}:${mi}`;
      }
      function appendLog(line) {
        const maxLines = 1200; // cap to avoid runaway memory
        const row = document.createElement("div");
        row.className = "line";
        const ts = document.createElement("span");
        ts.className = "ts";
        ts.textContent = `[${nowTs()}] `;
        const msg = document.createElement("span");
        msg.className = "msg";
        msg.textContent = line;
        row.append(ts, msg);
        if (log.firstChild) log.insertBefore(row, log.firstChild);
        else log.append(row);
        while (log.childNodes.length > maxLines) {
          log.removeChild(log.lastChild);
        }
        log.scrollTop = 0;
      }
      function setHttpStatus(ok, text) {
        httpDot.classList.toggle("ok", !!ok);
        httpStatusText.textContent = text;
      }
      function setWsStatus(ok, text) {
        wsDot.classList.toggle("ok", !!ok);
        if (wsStatusText) wsStatusText.textContent = text;
      }
      function setEditorModeStatus(enabled) {
        editorModeDot.classList.toggle("ok", enabled === true);
        editorModeDot.classList.toggle("warn", enabled !== true && enabled !== false);
        if (editorModeText) {
          editorModeText.textContent = enabled === true ? "enabled" : enabled === false ? "disabled" : "unknown";
        }
      }

      // Copy/Clear log
      copyLogBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(log.textContent || "");
          appendLog("UI: log copied to clipboard");
        } catch (e) {
          appendLog(`UI: copy failed: ${String(e)}`);
        }
      });
      clearLogBtn.addEventListener("click", () => {
        log.textContent = "";
        appendLog("UI: log cleared");
      });

      // Base URL labels
      function refreshBaseLabels() {
        httpBaseLabel.textContent = httpBase.value.trim();
        wsBaseLabel.textContent = wsBase.value.trim();
      }
      httpBase.addEventListener("input", refreshBaseLabels);
      wsBase.addEventListener("input", refreshBaseLabels);
      refreshBaseLabels();

      // HTTP fetch wrappers
      async function httpGet(path) {
        const base = httpBase.value.trim().replace(/\/$/, "");
        const url = base + path;
        appendLog(`HTTP → GET ${url}`);
        try {
          const resp = await fetch(url, { method: "GET" });
          const ct = resp.headers.get("content-type") || "";
          let body;
          if (ct.includes("application/json")) body = await resp.json();
          else body = await resp.text();

          lastHttpResp.textContent = typeof body === "string" ? body : JSON.stringify(body);
          lastHttpErr.textContent = "—";
          setHttpStatus(resp.ok, resp.ok ? "ok" : `error ${resp.status}`);
          appendLog(`HTTP ← ${resp.status} ${resp.statusText} :: ${typeof body === "string" ? body : JSON.stringify(body)}`);
          return body;
        } catch (e) {
          lastHttpErr.textContent = String(e);
          setHttpStatus(false, "network error");
          appendLog(`HTTP !! error :: ${String(e)}`);
          throw e;
        }
      }


      async function httpPostJson(path, bodyObj) {
        const base = httpBase.value.trim().replace(/\/$/, "");
        const url = base + path;
        appendLog(`HTTP → POST ${url} (application/json)`);
        try {
          const resp = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify(bodyObj)
          });

          const body = await resp.text();
          lastHttpResp.textContent = body;
          lastHttpErr.textContent = "—";
          setHttpStatus(resp.ok, resp.ok ? "ok" : `error ${resp.status}`);
          appendLog(`HTTP ← ${resp.status} ${resp.statusText} :: ${body}`);
          return body;
        } catch (e) {
          lastHttpErr.textContent = String(e);
          setHttpStatus(false, "network error");
          appendLog(`HTTP !! error :: ${String(e)}`);
          throw e;
        }
      }

      async function httpPostText(path, bodyText, contentType) {
        const base = httpBase.value.trim().replace(/\/$/, "");
        const url = base + path;
        const ct = contentType || "application/json";
        appendLog(`HTTP → POST ${url} (${ct})`);
        try {
          const resp = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": ct },
            body: bodyText ?? ""
          });

          const body = await resp.text();
          lastHttpResp.textContent = body;
          lastHttpErr.textContent = "—";
          setHttpStatus(resp.ok, resp.ok ? "ok" : `error ${resp.status}`);
          appendLog(`HTTP ← ${resp.status} ${resp.statusText} :: ${body}`);
          return body;
        } catch (e) {
          lastHttpErr.textContent = String(e);
          setHttpStatus(false, "network error");
          appendLog(`HTTP !! error :: ${String(e)}`);
          throw e;
        }
      }

      // Hook up HTTP buttons
      postBrailleBtn.addEventListener("click", () => httpPostText("/braille", brailleTextValue.value, "application/json"));
      getPingBtn.addEventListener("click", () => httpGet("/ping"));
      getClearBtn.addEventListener("click", () => httpGet("/clear"));
      getDevicesBtn.addEventListener("click", () => httpGet("/devices"));
      getActiveDeviceBtn.addEventListener("click", () => httpGet("/devices/active"));
      getTablesBtn.addEventListener("click", () => httpGet("/tables"));

      // WebSocket
      let ws = null;
      let lastWsJsonLog = null;

      function wsConnect() {
        const url = wsBase.value.trim();
        if (!url) return;

        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          appendLog("WS: already connected/connecting");
          return;
        }

        appendLog(`WS → connect ${url}`);
        setWsStatus(false, "connecting");
        ws = new WebSocket(url);

        ws.addEventListener("open", () => {
          setWsStatus(true, "connected");
          appendLog("WS: open");
        });

        ws.addEventListener("close", (ev) => {
          setWsStatus(false, `closed (${ev.code})`);
          appendLog(`WS: close code=${ev.code} reason=${ev.reason || "(none)"}`);
        });

        ws.addEventListener("error", () => {
          setWsStatus(false, "error");
          appendLog("WS: error");
        });

        ws.addEventListener("message", async (ev) => {
          const data = ev.data;
          if (typeof data === "string") {
            handleWsText(data);
            return;
          }
          if (data instanceof Blob) {
            const text = await data.text();
            handleWsText(text);
            return;
          }
          if (data instanceof ArrayBuffer) {
            const text = new TextDecoder().decode(data);
            handleWsText(text);
            return;
          }
          appendLog("WS <- (non-text message)");
        });
      }

      function wsDisconnect() {
        if (!ws) {
          appendLog("WS: no connection to close");
          return;
        }
        appendLog("WS → close");
        try { ws.close(1000, "client closed"); } catch {}
      }

      function wsSendEditorInput() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          appendLog("WS: not connected");
          return;
        }
        const text = (wsTextValue && wsTextValue.value ? wsTextValue.value : "").trim();
        const payload = { kind: "text", text };
        const msg = { type: "command", command: "editorInput", input: payload };
        appendLog("WS -> send editorInput: " + JSON.stringify(msg));
        ws.send(JSON.stringify(msg));
      }

      function wsSendEditorMode() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          appendLog("WS: not connected");
          return;
        }
        const msg = { type: "command", command: "setEditorMode", enabled: true };
        appendLog("WS -> send setEditorMode: " + JSON.stringify(msg));
        ws.send(JSON.stringify(msg));
        setEditorModeStatus(true);
      }

      function wsSendEditorModeDisable() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          appendLog("WS: not connected");
          return;
        }
        const msg = { type: "command", command: "setEditorMode", enabled: false };
        appendLog("WS -> send setEditorMode: " + JSON.stringify(msg));
        ws.send(JSON.stringify(msg));
        setEditorModeStatus(false);
      }

      function wsSendEditorKey(key) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          appendLog("WS: not connected");
          return;
        }
        const msg = { type: "command", command: "editorInput", input: { kind: "key", key } };
        appendLog("WS -> send editorInput: " + JSON.stringify(msg));
        ws.send(JSON.stringify(msg));
      }

      function handleWsText(text) {
        // Try parse JSON
        try {
          const obj = JSON.parse(text);
          // Update UI fields via prettyIncomingMessage, but log full JSON payload.
          prettyIncomingMessage(obj);
          const pretty = JSON.stringify(obj, null, 2);
          if (pretty === lastWsJsonLog) return; // de-dupe identical consecutive messages
          lastWsJsonLog = pretty;
          appendLog("WS <- JSON :: " + pretty);
        } catch {
          appendLog("WS <- TEXT " + text);
        }
      }

      function prettyIncomingMessage(o) {
        if (!o || typeof o !== "object") return String(o);

        const type = o.Type || o.type;
        const ok = typeof o.Ok !== "undefined" ? o.Ok : o.ok;
        const ts = o.TimestampUtc || o.timestampUtc || "";
        const sourceText = typeof o.SourceText !== "undefined" ? o.SourceText : (o.sourceText ?? "");
        const braille = o.Braille || o.braille || {};
        const meta = o.Meta || o.meta || {};
        const cursor = o.Cursor || o.cursor || {};

        if (type === "brailleLine") {
          if (brailleUnicode) brailleUnicode.value = braille.UnicodeText || braille.unicodeText || "";
          const activeTable = meta.ActiveTable || meta.activeTable || braille.Table || braille.table || "";
          const createdUtc = meta.CreatedUtc || meta.createdUtc || ts;
          if (brailleTable) brailleTable.value = activeTable;
          if (brailleTimestamp) brailleTimestamp.value = createdUtc;
          if (brailleSourceText) brailleSourceText.value = sourceText;
          const brailleText = braille.UnicodeText || braille.unicodeText || "(no braille)";
          const table = activeTable || "(no table)";
          return `brailleLine ok=${ok} table=${table} text=${brailleText}`;
        }
        if (type === "cursorContext") {
          if (cursorCellIndex) cursorCellIndex.value = typeof cursor.CellIndex !== "undefined" ? String(cursor.CellIndex) : (typeof cursor.cellIndex !== "undefined" ? String(cursor.cellIndex) : "");
          if (cursorTextIndex) cursorTextIndex.value = typeof cursor.TextIndex !== "undefined" ? String(cursor.TextIndex) : (typeof cursor.textIndex !== "undefined" ? String(cursor.textIndex) : "");
          if (cursorCharacter) cursorCharacter.value = cursor.Character || cursor.character || "";
          if (cursorWord) cursorWord.value = cursor.Word || cursor.word || "";
          if (cursorCellChar) cursorCellChar.value = braille.CellChar || braille.cellChar || "";
          if (cursorCellCodePoint) cursorCellCodePoint.value = braille.CellCodePoint || braille.cellCodePoint || "";
          if (cursorTable) cursorTable.value = o.Table || o.table || "";
          if (cursorTimestamp) cursorTimestamp.value = ts;
          if (cursorSourceText) cursorSourceText.value = sourceText;
          const cell = typeof cursor.CellIndex !== "undefined" ? cursor.CellIndex : (typeof cursor.cellIndex !== "undefined" ? cursor.cellIndex : "?");
          const textIndex = typeof cursor.TextIndex !== "undefined" ? cursor.TextIndex : (typeof cursor.textIndex !== "undefined" ? cursor.textIndex : "?");
          const ch = cursor.Character || cursor.character || "?";
          return `cursorContext ok=${ok} cell=${cell} textIndex=${textIndex} char=${ch}`;
        }
        if (typeof o.MsgType !== "undefined") {
          return `keyEvent MsgType=${o.MsgType} UnitId=${o.UnitId} ButtonIndex=${o.ButtonIndex} IsPress=${o.IsPress} Name=${o.Name ?? ""} DotsMask=${o.DotsMask ?? ""}`;
        }
        return JSON.stringify(o);
      }

      // Hook up WS buttons
      wsConnectBtn.addEventListener("click", wsConnect);
      wsDisconnectBtn.addEventListener("click", wsDisconnect);
      wsSendInputBtn.addEventListener("click", wsSendEditorInput);
      wsSendModeBtn.addEventListener("click", wsSendEditorMode);
      wsSendModeDisableBtn.addEventListener("click", wsSendEditorModeDisable);
      wsSendBackspaceBtn.addEventListener("click", () => wsSendEditorKey("Backspace"));
      wsSendSpaceBtn.addEventListener("click", () => wsSendEditorKey("Space"));
      wsSendEnterBtn.addEventListener("click", () => wsSendEditorKey("Enter"));

      // On load: show initial instruction in log
      appendLog("UI ready. Use HTTP buttons or connect WebSocket.");
      appendLog("Spec: POST /braille, GET /ping, GET /clear, GET /devices, GET /tables.");
      appendLog("Spec: WS brailleLine/cursorContext/keyEvent in, editorInput/setEditorMode out.");
    })();
  </script>
</body>
</html>
