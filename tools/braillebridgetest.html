<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BrailleBridge Local API Test</title>

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #0f1620;
      --panel2: #101b27;
      --text: #e6edf3;
      --muted: #9fb0c0;
      --border: rgba(255,255,255,.10);
      --accent: #6aa6ff;
      --accent2: #7ee787;
      --danger: #ff6b6b;
      --warn: #ffd166;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    /* Light theme override */
    [data-theme="light"] {
      --bg: #f6f8fb;
      --panel: #ffffff;
      --panel2: #fbfcfe;
      --text: #0b1220;
      --muted: #4b5a6a;
      --border: rgba(10,20,40,.12);
      --accent: #2563eb;
      --accent2: #16a34a;
      --danger: #dc2626;
      --warn: #b45309;
      --shadow: 0 10px 30px rgba(0,0,0,.10);
    }

    /* Auto dark based on OS, unless user picked explicit theme */
    @media (prefers-color-scheme: light) {
      :root:not([data-theme]) {
        --bg: #f6f8fb;
        --panel: #ffffff;
        --panel2: #fbfcfe;
        --text: #0b1220;
        --muted: #4b5a6a;
        --border: rgba(10,20,40,.12);
        --accent: #2563eb;
        --accent2: #16a34a;
        --danger: #dc2626;
        --warn: #b45309;
        --shadow: 0 10px 30px rgba(0,0,0,.10);
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 15% 10%, rgba(106,166,255,.10), transparent 60%),
                  radial-gradient(900px 650px at 90% 25%, rgba(126,231,135,.10), transparent 55%),
                  var(--bg);
      color: var(--text);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(10px);
      background: color-mix(in oklab, var(--bg) 80%, transparent);
      border-bottom: 1px solid var(--border);
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 18px;
    }

    .topbar {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    .title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title h1 {
      font-size: 18px;
      margin: 0;
      letter-spacing: .2px;
    }

    .title .sub {
      font-size: 13px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, color-mix(in oklab, var(--panel) 92%, white 8%), var(--panel));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: var(--shadow);
      font-size: 13px;
      transition: transform .06s ease, border-color .15s ease;
    }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: color-mix(in oklab, var(--accent) 60%, var(--border)); }
    .btn.good { border-color: color-mix(in oklab, var(--accent2) 60%, var(--border)); }
    .btn.danger { border-color: color-mix(in oklab, var(--danger) 55%, var(--border)); }
    .btn.ghost { background: transparent; box-shadow: none; }

    main .wrap { padding-top: 16px; padding-bottom: 24px; }

    .grid {
      display: grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }

    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .hd {
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
    }

    .card .hd h2 {
      font-size: 14px;
      margin: 0;
      letter-spacing: .2px;
    }

    .card .hd .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      font-family: var(--mono);
    }

    .card .bd { padding: 14px; }

    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input[type="text"], textarea {
      width: 100%;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel) 92%, black 8%);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      outline: none;
      font-family: var(--mono);
    }

    textarea { min-height: 100px; resize: vertical; }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 560px) {
      .row { grid-template-columns: 1fr; }
    }

    .inline {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      font-family: var(--mono);
      user-select: none;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--danger) 18%, transparent);
    }
    .dot.ok {
      background: var(--accent2);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent2) 18%, transparent);
    }

    .log {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in oklab, var(--panel) 94%, black 6%);
      padding: 10px;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      max-height: 420px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .kpi {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .kpi .box {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      background: color-mix(in oklab, var(--panel2) 85%, transparent);
    }
    .kpi .box .v {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
    }

    .split {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    code.badge {
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel2) 70%, transparent);
      color: var(--text);
    }

    .warn {
      color: var(--warn);
      font-family: var(--mono);
      font-size: 12px;
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <div class="topbar">
        <div class="title">
          <h1>BrailleBridge Local API Test</h1>
          <div class="sub">
            HTTP: <span id="httpBaseLabel"></span> · WS: <span id="wsBaseLabel"></span>
          </div>
        </div>

        <div class="actions">
          <button class="btn ghost" id="themeBtn" title="Toggle theme">Toggle theme</button>
          <button class="btn" id="copyLogBtn" title="Copy log to clipboard">Copy log</button>
          <a class="btn" href="braillebridge://" title="Open BrailleBridge">Open BrailleBridge</a>
          <button class="btn danger" id="clearLogBtn" title="Clear log">Clear log</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div class="grid">

        <!-- Left: HTTP controls -->
        <section class="card">
          <div class="hd">
            <div>
              <h2>HTTP calls</h2>
              <div class="hint">POST /braille (plain text) · GET /clear · GET /ping · GET /devices · GET /braille/test</div>
            </div>
            <div class="pill">
              <span>HTTP status</span>
              <span class="dot" id="httpDot"></span>
              <span id="httpStatusText">unknown</span>
            </div>
          </div>

          <div class="bd">
            <div class="row">
              <div>
                <label for="httpBase">HTTP Base URL</label>
                <input id="httpBase" type="text" value="http://localhost:5000" />
              </div>
              <div>
                <label for="wsBase">WebSocket URL</label>
                <input id="wsBase" type="text" value="ws://localhost:5000/ws" />
              </div>
            </div>

            <div style="margin-top:12px;">
              <label for="brailleText">Text to send (plain text)</label>
              <textarea id="brailleText">Hello BrailleBridge</textarea>
            </div>

            <div class="inline" style="margin-top:10px;">
              <button class="btn primary" id="postBrailleBtn">POST /braille</button>
              <button class="btn" id="getPingBtn">GET /ping</button>
              <button class="btn danger" id="getClearBtn">GET /clear</button>
              <button class="btn" id="getDevicesBtn">GET /devices</button>
              <button class="btn" id="getBrailleTestBtn">GET /braille/test</button>
            </div>

            <div class="kpi">
              <div class="box">
                <div><strong>Last HTTP response</strong></div>
                <div class="v" id="lastHttpResp">—</div>
              </div>
              <div class="box">
                <div><strong>Last HTTP error</strong></div>
                <div class="v" id="lastHttpErr">—</div>
              </div>
            </div>

            <div class="small">
              Notes:
              <ul>
                <li>If you open this file via <code class="badge">file://</code>, some browsers can be stricter with CORS. Serving via <code class="badge">python -m http.server</code> is recommended.</li>
                <li>Your server must allow cross-origin requests. OPTIONS preflight is listed in your spec.</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- Right: WebSocket + Log -->
        <section class="card">
          <div class="hd">
            <div>
              <h2>WebSocket</h2>
              <div class="hint">Connect · Send UTF-8 text · Receive JSON key events</div>
            </div>
            <div class="pill">
              <span>WS</span>
              <span class="dot" id="wsDot"></span>
              <span id="wsStatusText">disconnected</span>
            </div>
          </div>

          <div class="bd">
            <div class="inline">
              <button class="btn good" id="wsConnectBtn">Connect</button>
              <button class="btn danger" id="wsDisconnectBtn">Disconnect</button>
              <button class="btn" id="wsSendTextBtn">Send text</button>
            </div>

            <div style="margin-top:12px;">
              <label for="wsSendText">Text to send over WS</label>
              <input id="wsSendText" type="text" value="Hello via WebSocket" />
            </div>

            <div style="margin-top:12px;">
              <label>Incoming events (JSON)</label>
              <div class="log" id="log"></div>
            </div>

            <div class="small">
              Parser:
              <span class="warn">Incoming messages are expected to be JSON (key events). If a message is plain text, it will be logged as text.</span>
            </div>
          </div>
        </section>

      </div>
    </div>
  </main>

  <script>
    (function () {
      const el = (id) => document.getElementById(id);

      // Elements
      const httpBase = el("httpBase");
      const wsBase = el("wsBase");
      const httpBaseLabel = el("httpBaseLabel");
      const wsBaseLabel = el("wsBaseLabel");

      const brailleText = el("brailleText");
      const postBrailleBtn = el("postBrailleBtn");
      const getPingBtn = el("getPingBtn");
      const getClearBtn = el("getClearBtn");
      const getDevicesBtn = el("getDevicesBtn");
      const getBrailleTestBtn = el("getBrailleTestBtn");

      const httpDot = el("httpDot");
      const httpStatusText = el("httpStatusText");
      const lastHttpResp = el("lastHttpResp");
      const lastHttpErr = el("lastHttpErr");

      const wsDot = el("wsDot");
      const wsStatusText = el("wsStatusText");
      const wsConnectBtn = el("wsConnectBtn");
      const wsDisconnectBtn = el("wsDisconnectBtn");
      const wsSendTextBtn = el("wsSendTextBtn");
      const wsSendText = el("wsSendText");

      const log = el("log");
      const themeBtn = el("themeBtn");
      const copyLogBtn = el("copyLogBtn");
      const clearLogBtn = el("clearLogBtn");

      // Theme
      function applyTheme(theme) {
        if (!theme) {
          document.documentElement.removeAttribute("data-theme");
          localStorage.removeItem("bb_theme");
          return;
        }
        document.documentElement.setAttribute("data-theme", theme);
        localStorage.setItem("bb_theme", theme);
      }
      function toggleTheme() {
        const cur = document.documentElement.getAttribute("data-theme");
        // If not set explicitly, infer current and toggle
        if (!cur) {
          const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          applyTheme(prefersLight ? "dark" : "light");
          return;
        }
        applyTheme(cur === "dark" ? "light" : "dark");
      }
      applyTheme(localStorage.getItem("bb_theme"));
      themeBtn.addEventListener("click", toggleTheme);

      // Log helpers
      function nowTs() {
        return new Date().toISOString();
      }
      function appendLog(line) {
        const max = 4000; // cap to avoid runaway memory
        const text = `[${nowTs()}] ${line}\n`;
        log.textContent += text;
        if (log.textContent.length > max * 10) {
          log.textContent = log.textContent.slice(-max * 10);
        }
        log.scrollTop = log.scrollHeight;
      }
      function setHttpStatus(ok, text) {
        httpDot.classList.toggle("ok", !!ok);
        httpStatusText.textContent = text;
      }
      function setWsStatus(ok, text) {
        wsDot.classList.toggle("ok", !!ok);
        wsStatusText.textContent = text;
      }

      // Copy/Clear log
      copyLogBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(log.textContent || "");
          appendLog("UI: log copied to clipboard");
        } catch (e) {
          appendLog(`UI: copy failed: ${String(e)}`);
        }
      });
      clearLogBtn.addEventListener("click", () => {
        log.textContent = "";
        appendLog("UI: log cleared");
      });

      // Base URL labels
      function refreshBaseLabels() {
        httpBaseLabel.textContent = httpBase.value.trim();
        wsBaseLabel.textContent = wsBase.value.trim();
      }
      httpBase.addEventListener("input", refreshBaseLabels);
      wsBase.addEventListener("input", refreshBaseLabels);
      refreshBaseLabels();

      // HTTP fetch wrappers
      async function httpGet(path) {
        const base = httpBase.value.trim().replace(/\/$/, "");
        const url = base + path;
        appendLog(`HTTP → GET ${url}`);
        try {
          const resp = await fetch(url, { method: "GET" });
          const ct = resp.headers.get("content-type") || "";
          let body;
          if (ct.includes("application/json")) body = await resp.json();
          else body = await resp.text();

          lastHttpResp.textContent = typeof body === "string" ? body : JSON.stringify(body);
          lastHttpErr.textContent = "—";
          setHttpStatus(resp.ok, resp.ok ? "ok" : `error ${resp.status}`);
          appendLog(`HTTP ← ${resp.status} ${resp.statusText} :: ${typeof body === "string" ? body : JSON.stringify(body)}`);
          return body;
        } catch (e) {
          lastHttpErr.textContent = String(e);
          setHttpStatus(false, "network error");
          appendLog(`HTTP !! error :: ${String(e)}`);
          throw e;
        }
      }

      async function httpPostPlain(path, text) {
        const base = httpBase.value.trim().replace(/\/$/, "");
        const url = base + path;
        appendLog(`HTTP → POST ${url} (text/plain)`);
        try {
          const resp = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "text/plain; charset=utf-8" },
            body: text
          });

          const body = await resp.text();
          lastHttpResp.textContent = body;
          lastHttpErr.textContent = "—";
          setHttpStatus(resp.ok, resp.ok ? "ok" : `error ${resp.status}`);
          appendLog(`HTTP ← ${resp.status} ${resp.statusText} :: ${body}`);
          return body;
        } catch (e) {
          lastHttpErr.textContent = String(e);
          setHttpStatus(false, "network error");
          appendLog(`HTTP !! error :: ${String(e)}`);
          throw e;
        }
      }

      // Hook up HTTP buttons
      postBrailleBtn.addEventListener("click", () => httpPostPlain("/braille", brailleText.value));
      getPingBtn.addEventListener("click", () => httpGet("/ping"));
      getClearBtn.addEventListener("click", () => httpGet("/clear"));
      getDevicesBtn.addEventListener("click", () => httpGet("/devices"));
      getBrailleTestBtn.addEventListener("click", () => httpGet("/braille/test"));

      // WebSocket
      let ws = null;

      function wsConnect() {
        const url = wsBase.value.trim();
        if (!url) return;

        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          appendLog("WS: already connected/connecting");
          return;
        }

        appendLog(`WS → connect ${url}`);
        setWsStatus(false, "connecting");
        ws = new WebSocket(url);

        ws.addEventListener("open", () => {
          setWsStatus(true, "connected");
          appendLog("WS: open");
        });

        ws.addEventListener("close", (ev) => {
          setWsStatus(false, `closed (${ev.code})`);
          appendLog(`WS: close code=${ev.code} reason=${ev.reason || "(none)"}`);
        });

        ws.addEventListener("error", () => {
          setWsStatus(false, "error");
          appendLog("WS: error");
        });

        ws.addEventListener("message", (ev) => {
          const data = ev.data;
          if (typeof data === "string") {
            // Try parse JSON
            try {
              const obj = JSON.parse(data);
              appendLog("WS ← JSON " + prettyKeyEvent(obj));
            } catch {
              appendLog("WS ← TEXT " + data);
            }
          } else {
            appendLog("WS ← (non-text message)");
          }
        });
      }

      function wsDisconnect() {
        if (!ws) {
          appendLog("WS: no connection to close");
          return;
        }
        appendLog("WS → close");
        try { ws.close(1000, "client closed"); } catch {}
      }

      function wsSend() {
        const text = wsSendText.value ?? "";
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          appendLog("WS: not connected");
          return;
        }
        appendLog("WS → send text: " + JSON.stringify(text));
        ws.send(text);
      }

      // Pretty print the key event (your specified schema)
      function prettyKeyEvent(o) {
        if (!o || typeof o !== "object") return String(o);

        // Core fields
        const parts = [];
        if (typeof o.MsgType !== "undefined") parts.push(`MsgType=${o.MsgType}`);
        if (typeof o.UnitId !== "undefined") parts.push(`UnitId=${o.UnitId}`);
        if (typeof o.Strip !== "undefined") parts.push(`Strip=${o.Strip}`);
        if (typeof o.ButtonIndex !== "undefined") parts.push(`ButtonIndex=${o.ButtonIndex}`);
        if (typeof o.IsPress !== "undefined") parts.push(`IsPress=${o.IsPress}`);

        // Mapped fields
        if (typeof o.Kind !== "undefined") parts.push(`Kind=${kindName(o.Kind)}(${o.Kind})`);
        if (typeof o.CursorIndex !== "undefined") parts.push(`CursorIndex=${o.CursorIndex}`);
        if (typeof o.Name !== "undefined") parts.push(`Name=${o.Name ?? "null"}`);

        // If additional fields exist, show compact JSON too
        const known = new Set(["MsgType","UnitId","Strip","ButtonIndex","IsPress","Kind","CursorIndex","Name"]);
        const extra = {};
        for (const k of Object.keys(o)) {
          if (!known.has(k)) extra[k] = o[k];
        }

        const base = parts.join(" ");
        if (Object.keys(extra).length > 0) {
          return base + " | extra=" + JSON.stringify(extra);
        }
        return base;
      }

      function kindName(k) {
        switch (k) {
          case 1: return "CursorRouting";
          case 2: return "ThumbKey";
          case 0: return "Unknown";
          default: return "Other";
        }
      }

      // Hook up WS buttons
      wsConnectBtn.addEventListener("click", wsConnect);
      wsDisconnectBtn.addEventListener("click", wsDisconnect);
      wsSendTextBtn.addEventListener("click", wsSend);

      // On load: show initial instruction in log
      appendLog("UI ready. Use HTTP buttons or connect WebSocket.");
      appendLog("Spec: POST /braille (plain text), GET /clear, GET /ping, GET /devices, GET /braille/test, WS send text / receive JSON key events.");
    })();
  </script>
</body>
</html>
