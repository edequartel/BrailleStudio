<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MediaPipe Hands — Index Fingertip Coordinates</title>

  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: #0b0e14;
      color: #e9effa;
      margin: 16px;
    }
    h1 {
      font-size: 18px;
      margin: 0 0 12px 0;
    }
    .wrap {
      max-width: 820px;
      margin: 0 auto;
      display: grid;
      gap: 12px;
    }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    button, select, input[type="checkbox"] {
      font-size: 14px;
    }
    button {
      padding: 10px 14px;
      border: 0;
      border-radius: 10px;
      background: #2a3350;
      color: #e9effa;
      cursor: pointer;
    }
    button:hover { filter: brightness(1.08); }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    .panel {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px;
    }
    .videoWrap {
      position: relative;
      width: 100%;
      max-width: 800px;
      aspect-ratio: 4 / 3;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      background: #000;
    }
    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
    }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .hint {
      opacity: 0.85;
      font-size: 13px;
      line-height: 1.35;
    }
    label {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>MediaPipe Hands — Index fingertip (landmark 8) coordinates</h1>

    <div class="panel">
      <div class="row">
        <button id="btnStart">Start camera</button>
        <button id="btnStop" disabled>Stop</button>
        <span class="pill" id="status">Idle</span>

        <label class="pill">
          <input id="chkMirror" type="checkbox" checked />
          Mirror (selfie)
        </label>

        <label class="pill">
          <input id="chkExtend" type="checkbox" />
          Extend tip a bit (uses landmark 7→8 vector)
        </label>
      </div>

      <div class="hint" style="margin-top:10px">
        Tip of index finger = <b>landmark 8</b>. Coordinates are normalized (0..1). Pixel coordinates are derived from the canvas size.
        Allow camera permissions when asked.
      </div>
    </div>

    <div class="videoWrap">
      <video id="video" playsinline></video>
      <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <div class="panel">
      <pre class="mono" id="out">Waiting…</pre>
    </div>
  </div>

  <!-- MediaPipe Hands + helpers -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const out = document.getElementById("out");
    const statusEl = document.getElementById("status");

    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const chkMirror = document.getElementById("chkMirror");
    const chkExtend = document.getElementById("chkExtend");

    let camera = null;

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function clamp01(v) {
      return Math.max(0, Math.min(1, v));
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    hands.onResults((results) => {
      // Draw camera frame
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Mirror if selfie mode
      if (chkMirror.checked) {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      }

      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      // No hands
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        ctx.restore();
        out.textContent = JSON.stringify({ hands: 0 }, null, 2);
        setStatus("No hands");
        return;
      }

      // Use first detected hand
      const landmarks = results.multiHandLandmarks[0];

      // Index fingertip = 8, joint before = 7
      const tip = landmarks[8];
      const prev = landmarks[7];

      let x = tip.x;
      let y = tip.y;
      let z = tip.z;

      // Optionally extend a bit beyond the tip (more like “nail edge”)
      if (chkExtend.checked) {
        const dx = tip.x - prev.x;
        const dy = tip.y - prev.y;
        const dz = tip.z - prev.z;
        x = clamp01(tip.x + dx * 0.4);
        y = clamp01(tip.y + dy * 0.4);
        z = tip.z + dz * 0.4;
      }

      const px = Math.round(x * canvas.width);
      const py = Math.round(y * canvas.height);

      // Draw all landmarks lightly (optional)
      // drawConnectors(ctx, landmarks, HAND_CONNECTIONS);
      // drawLandmarks(ctx, landmarks);

      // Draw a clear dot at the index fingertip
      ctx.beginPath();
      ctx.arc(px, py, 10, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fill();

      // Draw a label
      ctx.font = "16px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillText(`Index tip: (${px}, ${py})`, Math.min(px + 14, canvas.width - 200), Math.max(py - 14, 24));

      ctx.restore();

      setStatus(`Tracking (hands: ${results.multiHandLandmarks.length})`);

      out.textContent = JSON.stringify({
        type: "indexTip",
        handIndex: 0,
        landmark: 8,
        extended: chkExtend.checked,
        normalized: { x, y, z },
        pixel: { x: px, y: py },
        canvas: { width: canvas.width, height: canvas.height }
      }, null, 2);
    });

    async function startCamera() {
      setStatus("Starting…");
      btnStart.disabled = true;

      // Camera helper will request the user's camera
      camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 800,
        height: 600
      });

      try {
        await camera.start();
        setStatus("Running");
        btnStop.disabled = false;
      } catch (err) {
        console.error(err);
        setStatus("Camera error — check permissions");
        btnStart.disabled = false;
        btnStop.disabled = true;
        camera = null;
      }
    }

    async function stopCamera() {
      setStatus("Stopping…");
      btnStop.disabled = true;

      try {
        // camera_utils Camera has no universal stop() across versions;
        // safest is: stop tracks from the video stream
        const stream = video.srcObject;
        if (stream && stream.getTracks) {
          stream.getTracks().forEach(t => t.stop());
        }
      } catch (e) {}

      // Clear visuals
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      out.textContent = "Stopped.";
      setStatus("Stopped");

      btnStart.disabled = false;
      camera = null;
    }

    btnStart.addEventListener("click", startCamera);
    btnStop.addEventListener("click", stopCamera);
  </script>
</body>
</html>