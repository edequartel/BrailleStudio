<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Invisible Theremin — MediaPipe Hands + WebAudio (screen-left/right)</title>
<style>
  body { font-family: system-ui; background:#0b0e14; color:#e9effa; margin:16px; }
  .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
  .videoWrap { position:relative; width:800px; height:600px; border-radius:14px; overflow:hidden; border:1px solid #223; }
  video, canvas { position:absolute; width:100%; height:100%; object-fit:cover; }
  .panel { min-width:340px; max-width:560px; padding:12px; border:1px solid #223; border-radius:14px; background:#0f1420; }
  button, select, input[type="range"]{
    width:100%; padding:10px; border-radius:12px; border:1px solid #223;
    background:#0b0e14; color:#e9effa; font-size:14px;
  }
  button{ cursor:pointer; margin-top:10px; font-weight:700; }
  label{ display:block; margin:10px 0 6px; font-size:13px; opacity:.95; }
  .pill { display:inline-block; padding:4px 10px; border:1px solid #223; border-radius:999px; margin-right:8px; }
  .hint { font-size:13px; opacity:.85; line-height:1.4; }
  .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; white-space:pre; }
</style>
</head>
<body>

<h2>✨ Invisible Theremin — screen-left hand = Volume, screen-right hand = Pitch</h2>

<div class="row">
  <div class="videoWrap">
    <video id="video" playsinline muted></video>
    <canvas id="canvas" width="800" height="600"></canvas>
  </div>

  <div class="panel">
    <div class="hint">
      Controls:
      <br>• <b>RIGHT side hand</b> → pitch (higher = higher note)
      <br>• <b>LEFT side hand</b> → volume (closer = louder)
      <br>• <b>Pinch</b> (thumb+index) on any hand → toggle <b>Vibrato</b>
      <br>• <b>Hands together</b> → <b>Mute</b>
      <br><br>
      Click <b>Start Audio</b> first (browser requirement).
    </div>

    <button id="startBtn">▶ Start Audio</button>

    <div style="margin-top:12px">
      <span class="pill" id="audioPill">Audio: OFF</span>
      <span class="pill" id="vibPill">Vibrato: OFF</span>
      <span class="pill" id="mutePill">Mute: OFF</span>
    </div>

    <label>Mirror view (selfie)</label>
    <select id="mirror">
      <option value="1" selected>On</option>
      <option value="0">Off</option>
    </select>

    <div class="grid2">
      <div>
        <label>Waveform</label>
        <select id="wave">
          <option value="sine" selected>sine</option>
          <option value="triangle">triangle</option>
          <option value="square">square</option>
          <option value="sawtooth">sawtooth</option>
        </select>
      </div>
      <div>
        <label>Scale</label>
        <select id="scale">
          <option value="chromatic" selected>Chromatic</option>
          <option value="major">Major</option>
          <option value="pentatonic">Pentatonic</option>
        </select>
      </div>
    </div>

    <label>Pitch max (Hz)</label>
    <input id="pitchMax" type="range" min="440" max="1760" value="880" />

    <div class="mono" id="readout" style="margin-top:10px">Waiting…</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const startBtn = document.getElementById("startBtn");
const audioPill = document.getElementById("audioPill");
const vibPill = document.getElementById("vibPill");
const mutePill = document.getElementById("mutePill");

const mirrorEl = document.getElementById("mirror");
const waveEl = document.getElementById("wave");
const scaleEl = document.getElementById("scale");
const pitchMaxEl = document.getElementById("pitchMax");
const readout = document.getElementById("readout");

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function dist2D(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

function setPill(el, label, on){
  el.textContent = `${label}: ${on ? "ON" : "OFF"}`;
  el.style.borderColor = on ? "lime" : "#223";
}

// ---------- Audio engine ----------
let audioCtx = null;
let osc = null;
let gain = null;
let filter = null;

let vibOsc = null;
let vibGain = null;
let vibratoOn = false;
let mutedByHands = false;

let smoothPitch = 220;
let smoothVol = 0;

function ensureAudio(){
  if (audioCtx) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  osc = audioCtx.createOscillator();
  gain = audioCtx.createGain();
  filter = audioCtx.createBiquadFilter();

  filter.type = "lowpass";
  filter.frequency.value = 6000;

  osc.type = waveEl.value;
  osc.frequency.value = 220;

  gain.gain.value = 0;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);

  vibOsc = audioCtx.createOscillator();
  vibGain = audioCtx.createGain();
  vibOsc.type = "sine";
  vibOsc.frequency.value = 6;
  vibGain.gain.value = 0;
  vibOsc.connect(vibGain);
  vibGain.connect(osc.frequency);

  osc.start();
  vibOsc.start();

  setPill(audioPill, "Audio", true);
}

function setVibrato(on){
  vibratoOn = on;
  if (vibGain) vibGain.gain.value = on ? 18 : 0;
  setPill(vibPill, "Vibrato", on);
}

function setMute(on){
  mutedByHands = on;
  setPill(mutePill, "Mute", on);
  if (gain && audioCtx) gain.gain.setTargetAtTime(on ? 0 : smoothVol, audioCtx.currentTime, 0.01);
}

startBtn.addEventListener("click", async () => {
  ensureAudio();
  if (audioCtx.state === "suspended") await audioCtx.resume();
  startBtn.textContent = "Audio running ✅";
  startBtn.disabled = true;
});

waveEl.addEventListener("change", () => { if (osc) osc.type = waveEl.value; });

// ---------- Music mapping ----------
function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

function quantizeToScale(freq, scaleName){
  const A4 = 440;
  const midi = 69 + 12 * Math.log2(freq / A4);
  const base = Math.round(midi);

  if (scaleName === "chromatic") return midiToFreq(base);

  const major = [0,2,4,5,7,9,11];
  const penta = [0,2,4,7,9];
  const scale = (scaleName === "pentatonic") ? penta : major;

  const octave = Math.floor(base / 12);
  let best = base, bestDist = Infinity;

  for (let o = octave - 1; o <= octave + 1; o++){
    for (const s of scale){
      const cand = o*12 + s; // relative to C
      const d = Math.abs(cand - base);
      if (d < bestDist){ bestDist = d; best = cand; }
    }
  }
  return midiToFreq(best);
}

// ---------- Gesture logic ----------
const PINCH_THRESHOLD = 0.055;
const HANDS_TOGETHER_THRESH = 0.18;
let pinchLatch = false;

function pinchActive(lms){
  const t = lms[4], i = lms[8];
  const d = Math.hypot(t.x - i.x, t.y - i.y);
  return d < PINCH_THRESHOLD;
}

function handScreenX(lms, mirror){
  // Use wrist (0) x position and convert to screen-space (mirror-aware)
  const x = lms[0].x;
  return mirror ? (1 - x) : x;
}

function landmarkToPx(lm, mirror){
  let x = lm.x * canvas.width;
  let y = lm.y * canvas.height;
  if (mirror) x = canvas.width - x;
  return {x,y};
}

// ---------- MediaPipe ----------
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults((results) => {
  const mirror = mirrorEl.value === "1";

  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (mirror) {
    ctx.save();
    ctx.scale(-1, 1);
    ctx.drawImage(results.image, -canvas.width, 0, canvas.width, canvas.height);
    ctx.restore();
  } else {
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
  }

  const lmsArr = results.multiHandLandmarks || [];
  const handedArr = results.multiHandedness || [];

  if (!lmsArr.length) {
    readout.textContent = "No hands detected";
    if (gain && audioCtx && !mutedByHands) gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
    return;
  }

  // Build hands with screen-x ordering (LEFT side / RIGHT side on screen)
  const handsFound = lmsArr.map((lms, i) => ({
    lms,
    label: handedArr[i]?.label || "Unknown",
    sx: handScreenX(lms, mirror)
  })).sort((a,b) => a.sx - b.sx);

  const leftSideHand = handsFound[0];
  const rightSideHand = handsFound.length > 1 ? handsFound[handsFound.length - 1] : handsFound[0];

  // Hands together mute (use wrists)
  if (handsFound.length > 1) {
    const d = dist2D(handsFound[0].lms[0].x, handsFound[0].lms[0].y,
                     handsFound[1].lms[0].x, handsFound[1].lms[0].y);
    setMute(d < HANDS_TOGETHER_THRESH);
  } else {
    setMute(false);
  }

  // Pinch toggles vibrato
  const anyPinch = handsFound.some(h => pinchActive(h.lms));
  if (anyPinch && !pinchLatch) { pinchLatch = true; setVibrato(!vibratoOn); }
  if (!anyPinch && pinchLatch) pinchLatch = false;

  // Pitch: RIGHT side hand index tip height
  const idxTip = rightSideHand.lms[8];
  const y = idxTip.y;
  const pitchMin = 110;
  const pitchMax = parseInt(pitchMaxEl.value, 10);
  let targetPitch = lerp(pitchMax, pitchMin, clamp(y, 0, 1));
  targetPitch = quantizeToScale(targetPitch, scaleEl.value);

  // Volume: LEFT side hand wrist z (closer -> louder)
  const z = leftSideHand.lms[0].z; // wrist z
  // Map z approx [-0.25..0.05] => volume [1..0.05]
  const zn = clamp((z - 0.05) / (-0.30), 0, 1);
  let targetVol = lerp(0.05, 1.0, zn);
  if (mutedByHands) targetVol = 0;

  // Smooth
  smoothPitch = lerp(smoothPitch, targetPitch, 0.22);
  smoothVol = lerp(smoothVol, targetVol, 0.25);

  // Apply audio
  if (audioCtx && osc && gain) {
    osc.type = waveEl.value;
    osc.frequency.setTargetAtTime(smoothPitch, audioCtx.currentTime, 0.02);
    gain.gain.setTargetAtTime(smoothVol, audioCtx.currentTime, 0.03);

    if (filter) {
      const f = clamp(smoothPitch * 6, 700, 9000);
      filter.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.03);
    }
  }

  // Draw index tips for both hands
  ctx.save();
  ctx.fillStyle = "white";
  for (const h of handsFound) {
    const p = landmarkToPx(h.lms[8], mirror);
    ctx.beginPath(); ctx.arc(p.x, p.y, 7, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // Label which hand is volume vs pitch
  const pitchP = landmarkToPx(rightSideHand.lms[8], mirror);
  const volP = landmarkToPx(leftSideHand.lms[0], mirror);

  ctx.save();
  ctx.font = "16px ui-monospace, SFMono-Regular, Menlo, monospace";
  ctx.fillStyle = "lime";
  ctx.fillText("PITCH (screen-right)", pitchP.x + 12, pitchP.y - 12);
  ctx.fillStyle = "cyan";
  ctx.fillText("VOLUME (screen-left)", volP.x + 12, volP.y - 12);
  ctx.restore();

  readout.textContent = JSON.stringify({
    audio: !!audioCtx,
    vibratoOn,
    mutedByHands,
    screenLeftHandLabel: leftSideHand.label,
    screenRightHandLabel: rightSideHand.label,
    pitchHz: Math.round(smoothPitch),
    volume: Number(smoothVol.toFixed(2)),
    pinch: anyPinch,
    handsDetected: handsFound.map(h => ({ label: h.label, screenX: Number(h.sx.toFixed(2)) }))
  }, null, 2);
});

const camera = new Camera(video, {
  onFrame: async () => { await hands.send({ image: video }); },
  width: 800,
  height: 600
});
camera.start();
</script>

</body>
</html>