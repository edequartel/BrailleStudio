<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>API Speech (TTS) Monitor</title>

  <!-- Howler.js -->
  <script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

  <style>
    :root {
      color-scheme: dark;
      --bg0: #0b1020;
      --bg1: rgba(255, 255, 255, 0.06);
      --bg2: rgba(255, 255, 255, 0.09);
      --fg0: rgba(255, 255, 255, 0.92);
      --fg1: rgba(255, 255, 255, 0.72);
      --fg2: rgba(255, 255, 255, 0.58);
      --bdr: rgba(255, 255, 255, 0.14);
      --ok: #39d98a;
      --bad: #ff5c7a;
      --warn: #ffd36b;
      --acc: #7aa7ff;
      --acc2: #b38cff;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --r: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--font);
      color: var(--fg0);
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(122, 167, 255, 0.28), transparent 60%),
        radial-gradient(900px 600px at 95% 25%, rgba(179, 140, 255, 0.24), transparent 55%),
        radial-gradient(900px 600px at 30% 95%, rgba(57, 217, 138, 0.16), transparent 55%),
        linear-gradient(180deg, #070a14, var(--bg0));
      min-height: 100vh;
    }

    .wrap { max-width: 1100px; margin: 0 auto; padding: 26px 18px 34px; }
    .topbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 16px;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    h1 { margin: 0; font-size: 20px; font-weight: 720; letter-spacing: 0.2px; }
    .subtitle { color: var(--fg1); font-size: 13px; }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
    }
    .pill {
      border: 1px solid var(--bdr);
      background: var(--bg1);
      padding: 8px 10px;
      border-radius: 999px;
      box-shadow: var(--shadow);
      display: inline-flex;
      gap: 8px;
      align-items: baseline;
      white-space: nowrap;
    }
    .pill b { font-size: 13px; }
    .pill span { font-size: 12px; color: var(--fg1); }
    .pill.ok b { color: var(--ok); }
    .pill.bad b { color: var(--bad); }
    .pill.warn b { color: var(--warn); }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 14px;
      align-items: start;
    }
    @media (max-width: 920px) {
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      border: 1px solid var(--bdr);
      background: var(--bg1);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .card .hd {
      padding: 12px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), transparent);
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .card .hd h2 { margin: 0; font-size: 14px; letter-spacing: 0.2px; }
    .card .hd h2 { margin-right: auto; }
    .card .hd .btns { margin-left: auto; justify-content: flex-end; }
    .card .bd { padding: 14px; }

    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 520px) { .row { grid-template-columns: 1fr; } }

    .row.tight-right { grid-template-columns: 1fr 220px; }
    @media (max-width: 520px) { .row.tight-right { grid-template-columns: 1fr; } }

    label { display: grid; gap: 6px; font-size: 12px; color: var(--fg1); }
    label.compact { align-content: start; }
    label.compact select { max-width: 180px; justify-self: end; }
    input[type="text"], input[type="password"], textarea, select {
      width: 100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(10, 14, 28, 0.65);
      color: var(--fg0);
      outline: none;
    }
    textarea { min-height: 110px; resize: vertical; }
    input:focus, textarea:focus, select:focus { border-color: rgba(122, 167, 255, 0.55); box-shadow: 0 0 0 3px rgba(122, 167, 255, 0.15); }
    .hint { color: var(--fg2); font-size: 12px; line-height: 1.35; }
    .mono { font-family: var(--mono); }

    .btns { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    button {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: var(--fg0);
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    button:hover { background: rgba(255,255,255,0.11); border-color: rgba(255,255,255,0.28); transform: translateY(-1px); }
    button:active { transform: translateY(0px); }
    button.primary {
      background: linear-gradient(135deg, rgba(122, 167, 255, 0.35), rgba(179, 140, 255, 0.24));
      border-color: rgba(122, 167, 255, 0.40);
    }
    button.danger { border-color: rgba(255, 92, 122, 0.35); }
    button:disabled { opacity: 0.55; cursor: not-allowed; transform: none; }

    .statusline {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--fg1);
      font-size: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }
    .dot { width: 9px; height: 9px; border-radius: 99px; background: rgba(255,255,255,0.22); display: inline-block; }
    .dot.ok { background: var(--ok); }
    .dot.bad { background: var(--bad); }
    .dot.warn { background: var(--warn); }

    .logwrap { height: 360px; overflow: auto; }
    table { width: 100%; border-collapse: collapse; }
    thead th {
      position: sticky;
      top: 0;
      background: rgba(10, 14, 28, 0.92);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(255,255,255,0.12);
      font-size: 12px;
      color: var(--fg1);
      text-align: left;
      padding: 10px 12px;
    }
    tbody td {
      border-bottom: 1px solid rgba(255,255,255,0.06);
      padding: 10px 12px;
      vertical-align: top;
      font-size: 12px;
      color: var(--fg1);
    }
    tbody tr:hover td { background: rgba(255,255,255,0.04); }
    .tag {
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      color: var(--fg0);
      display: inline-flex;
      gap: 6px;
      align-items: center;
      white-space: nowrap;
    }
    .tag.ok { border-color: rgba(57, 217, 138, 0.38); color: rgba(57, 217, 138, 0.95); }
    .tag.bad { border-color: rgba(255, 92, 122, 0.45); color: rgba(255, 92, 122, 0.95); }
    .tag.warn { border-color: rgba(255, 211, 107, 0.50); color: rgba(255, 211, 107, 0.95); }
    .small { color: var(--fg2); font-size: 11px; }
    .nowrap { white-space: nowrap; }

  </style>
</head>
<body>

  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>API Speech (TTS) Monitor</h1>
        <div class="subtitle">Speel spraak af en bekijk request/response traffic (zonder secrets te loggen).</div>
      </div>
      <div class="stats" aria-label="Traffic stats">
        <div class="pill"><b id="statTotal">0</b><span>requests</span></div>
        <div class="pill ok"><b id="statOk">0</b><span>ok</span></div>
        <div class="pill bad"><b id="statErr">0</b><span>errors</span></div>
        <div class="pill warn"><b id="statMs">—</b><span>last ms</span></div>
        <div class="pill"><b id="statBytes">0</b><span>bytes</span></div>
      </div>
    </div>

    <div class="grid">
      <section class="card" aria-label="TTS controls">
        <div class="hd">
          <h2>Speak</h2>
          <div class="btns">
            <button id="playFullBtn" class="primary" type="button" title="Play memo as full TTS">Full</button>
            <button id="playScriptBtn" type="button" title="Play memo with <...> tokens as letter audio">&lt;&gt;</button>
            <button id="stopBtn" class="danger" type="button" disabled title="Stop playback">Stop</button>
            <button id="downloadBtn" type="button" disabled title="Download last Full TTS as mp3">Download</button>
          </div>
        </div>
        <div class="bd">
          <div class="row">
            <label>
              API key
              <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
              <div class="hint">Tip: zet ‘Remember’ aan om lokaal op te slaan (localStorage). Nooit gelogd.</div>
            </label>
            <label>
              Endpoint
              <input id="endpoint" type="text" class="mono" value="https://api.openai.com/v1/audio/speech" />
              <div class="hint">Gebruik dezelfde origin/proxy als je CORS issues hebt.</div>
            </label>
          </div>

          <div class="row" style="margin-top: 10px;">
            <label>
              Model
              <select id="model">
                <option value="gpt-4o-mini-tts" selected>gpt-4o-mini-tts</option>
              </select>
            </label>
            <label>
              Voice
              <select id="voice">
                <option value="alloy">alloy</option>
                <option value="ash" selected>ash</option>
                <option value="coral">coral</option>
                <option value="echo">echo</option>
                <option value="fable">fable</option>
                <option value="onyx">onyx</option>
                <option value="nova">nova</option>
                <option value="sage">sage</option>
                <option value="shimmer">shimmer</option>
              </select>
            </label>
          </div>

          <label style="margin-top: 10px;">
            Memo text
            <textarea id="memoText">Dit is de letter <a> de <a> typ je met punt 1.</textarea>
            <div class="hint"><span id="charCount">0</span> chars. Use <span class="mono">&lt;a&gt;</span> or <span class="mono">&lt;a.mp3&gt;</span> to play letter audio in “&lt;&gt;”.</div>
          </label>

          <div class="row tight-right" style="margin-top: 10px;">
            <label>
              Letter base URL
              <input id="letterBaseUrl" type="text" class="mono" value="https://www.tastenbraille.com/braillestudio/sounds/nl/alfabet/" />
              <div class="hint">For tokens like <span class="mono">&lt;a&gt;</span> ⇒ <span class="mono">a.mp3</span>.</div>
            </label>
            <label class="compact">
              Autoscroll log
              <select id="autoscroll">
                <option value="on" selected>on</option>
                <option value="off">off</option>
              </select>
            </label>
          </div>

          <div class="row" style="margin-top: 10px;">
            <label>
              Remember key
              <select id="rememberKey">
                <option value="off" selected>off</option>
                <option value="on">on (localStorage)</option>
              </select>
            </label>
          </div>

          <div class="statusline" role="status" aria-live="polite">
            <div style="display:flex; gap:10px; align-items:center;">
              <span id="stateDot" class="dot"></span>
              <span id="stateText">Idle</span>
            </div>
            <span id="stateDetail" class="small mono"></span>
          </div>
        </div>
      </section>

      <section class="card" aria-label="Traffic log">
        <div class="hd">
          <h2>Traffic log</h2>
          <div class="btns">
            <button id="clearLogBtn" type="button">Clear</button>
          </div>
        </div>
        <div class="logwrap" id="logWrap">
          <table>
            <thead>
              <tr>
                <th class="nowrap">Time</th>
                <th>Request</th>
                <th class="nowrap">Status</th>
                <th class="nowrap">ms</th>
                <th class="nowrap">bytes</th>
              </tr>
            </thead>
            <tbody id="logBody"></tbody>
          </table>
        </div>
      </section>
    </div>
  </div>

  <script>
    let currentSound = null;
    let currentRequest = null;
    let currentAudioUrl = null;
    let currentAudioBlob = null;
    let playSession = 0;

    const LS_KEY_REMEMBER = "apiSpeech.rememberKey";
    const LS_KEY_APIKEY = "apiSpeech.apiKey";

    const els = {
      apiKey: document.getElementById("apiKey"),
      endpoint: document.getElementById("endpoint"),
      model: document.getElementById("model"),
      voice: document.getElementById("voice"),
      letterBaseUrl: document.getElementById("letterBaseUrl"),
      memoText: document.getElementById("memoText"),
      playFullBtn: document.getElementById("playFullBtn"),
      playScriptBtn: document.getElementById("playScriptBtn"),
      stopBtn: document.getElementById("stopBtn"),
      downloadBtn: document.getElementById("downloadBtn"),
      rememberKey: document.getElementById("rememberKey"),
      autoscroll: document.getElementById("autoscroll"),
      logBody: document.getElementById("logBody"),
      logWrap: document.getElementById("logWrap"),
      clearLogBtn: document.getElementById("clearLogBtn"),
      stateDot: document.getElementById("stateDot"),
      stateText: document.getElementById("stateText"),
      stateDetail: document.getElementById("stateDetail"),
      charCount: document.getElementById("charCount"),
      statTotal: document.getElementById("statTotal"),
      statOk: document.getElementById("statOk"),
      statErr: document.getElementById("statErr"),
      statMs: document.getElementById("statMs"),
      statBytes: document.getElementById("statBytes"),
    };

    const stats = { total: 0, ok: 0, err: 0, bytes: 0, lastMs: null };
    const logRowsById = new Map();

    function fmtTime(d) {
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      const ss = String(d.getSeconds()).padStart(2, "0");
      const ms = String(d.getMilliseconds()).padStart(3, "0");
      return `${hh}:${mm}:${ss}.${ms}`;
    }

    function clampText(s, max = 160) {
      const t = String(s ?? "").replace(/\s+/g, " ").trim();
      return t.length > max ? t.slice(0, max - 1) + "…" : t;
    }

    function setState(kind, text, detail = "") {
      els.stateDot.className = "dot" + (kind ? " " + kind : "");
      els.stateText.textContent = text;
      els.stateDetail.textContent = detail;
    }

    function updateStats() {
      els.statTotal.textContent = String(stats.total);
      els.statOk.textContent = String(stats.ok);
      els.statErr.textContent = String(stats.err);
      els.statBytes.textContent = String(stats.bytes);
      els.statMs.textContent = stats.lastMs == null ? "—" : String(stats.lastMs);
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    function makeTimestampedName(prefix, ext) {
      const ts = new Date();
      const yyyy = String(ts.getFullYear());
      const mm = String(ts.getMonth() + 1).padStart(2, "0");
      const dd = String(ts.getDate()).padStart(2, "0");
      const hh = String(ts.getHours()).padStart(2, "0");
      const mi = String(ts.getMinutes()).padStart(2, "0");
      const ss = String(ts.getSeconds()).padStart(2, "0");
      return `${prefix}-${yyyy}${mm}${dd}-${hh}${mi}${ss}.${ext}`;
    }

    function updateDownloadButton() {
      els.downloadBtn.disabled = !currentAudioBlob;
    }

    function addLogRow(entry) {
      const tr = document.createElement("tr");
      tr.dataset.id = entry.id;
      const metaHtml =
        entry.kind === "asset"
          ? `<div class="small">asset=${entry.assetName}</div>`
          : `<div class="small">model=${entry.model}, voice=${entry.voice}, chars=${entry.chars}</div>`;
      tr.innerHTML = `
        <td class="mono nowrap">${entry.time}</td>
        <td>
          <div class="mono">${entry.method} ${entry.path}</div>
          ${metaHtml}
          ${entry.note ? `<div class="small">${entry.note}</div>` : ``}
        </td>
        <td class="nowrap"><span class="tag warn"><span class="dot warn"></span><span>pending</span></span></td>
        <td class="mono nowrap">—</td>
        <td class="mono nowrap">—</td>
      `;
      els.logBody.prepend(tr);
      logRowsById.set(entry.id, tr);
      if (els.autoscroll.value === "on") {
        els.logWrap.scrollTop = 0;
      }
      return tr;
    }

    function finalizeLogRow(id, result) {
      const tr = logRowsById.get(id);
      if (!tr) return;
      const statusTd = tr.children[2];
      const msTd = tr.children[3];
      const bytesTd = tr.children[4];

      const ok = Boolean(result.ok);
      const klass = ok ? "ok" : "bad";
      const label = ok ? `${result.status}` : `ERR ${result.status ?? ""}`.trim();
      statusTd.innerHTML = `<span class="tag ${klass}"><span class="dot ${klass}"></span><span>${label}</span></span>`;
      msTd.textContent = result.ms == null ? "—" : String(result.ms);
      bytesTd.textContent = result.bytes == null ? "—" : String(result.bytes);

      const metaTd = tr.children[1];
      if (result.errorText) {
        const div = document.createElement("div");
        div.className = "small mono";
        div.textContent = clampText(result.errorText, 260);
        metaTd.appendChild(div);
      }
    }

    function stopPlayback({ abortRequest = true, stopSound = true, revokeUrl = false, bumpSession = false } = {}) {
      if (bumpSession) playSession += 1;
      if (abortRequest && currentRequest) {
        try { currentRequest.abort(); } catch {}
        currentRequest = null;
      }

      if (currentSound) {
        if (stopSound) {
          try { currentSound.stop(); } catch {}
        }
        try { currentSound.unload(); } catch {}
        currentSound = null;
      }

      if (revokeUrl && currentAudioUrl) {
        try { URL.revokeObjectURL(currentAudioUrl); } catch {}
        currentAudioUrl = null;
      }
    }

    function parseScript(input) {
      const s = String(input ?? "");
      const parts = [];
      const re = /<([^>]+)>/g;
      let lastIdx = 0;
      let m;
      while ((m = re.exec(s)) !== null) {
        const before = s.slice(lastIdx, m.index);
        if (before.trim()) parts.push({ type: "tts", text: before });

        const raw = String(m[1] ?? "").trim();
        if (raw) parts.push({ type: "asset", token: raw });
        lastIdx = re.lastIndex;
      }
      const tail = s.slice(lastIdx);
      if (tail.trim()) parts.push({ type: "tts", text: tail });
      return parts;
    }

    function normalizeForTtsOnly(input) {
      // Treat <a> tokens as plain text "a" for full-text TTS mode.
      return String(input ?? "").replace(/<([^>]+)>/g, (_m, inner) => ` ${String(inner ?? "").trim()} `);
    }

    function resolveLetterUrl(token) {
      let t = String(token ?? "").trim();
      if (!t) return null;
      t = t.replace(/^["']|["']$/g, "");

      // Allow full URLs inside the token: <https://.../a.mp3>
      if (/^https?:\/\//i.test(t)) {
        try { return new URL(t).toString(); } catch { return null; }
      }

      const base = els.letterBaseUrl.value.trim();
      if (!base) return null;

      const normalized = t.toLowerCase();
      const filename = normalized.endsWith(".mp3") ? normalized : `${normalized}.mp3`;
      try {
        const u = new URL(base.endsWith("/") ? base : base + "/");
        u.pathname = u.pathname.replace(/\/?$/, "/") + encodeURIComponent(filename);
        return u.toString();
      } catch {
        return null;
      }
    }

    async function fetchMp3Blob(url, { sessionId } = {}) {
      const started = performance.now();
      let resp;
      try {
        resp = await fetch(url, { method: "GET" });
      } catch (e) {
        const ms = Math.round(performance.now() - started);
        if (sessionId != null && sessionId !== playSession) return { aborted: true };
        return { ok: false, status: "fetch", ms, errorText: String(e?.message ?? e) };
      }

      const ms = Math.round(performance.now() - started);
      if (sessionId != null && sessionId !== playSession) return { aborted: true };

      if (!resp.ok) {
        let errText = "";
        try { errText = await resp.text(); } catch {}
        return { ok: false, status: resp.status, ms, errorText: errText || resp.statusText };
      }

      let blob;
      try {
        blob = await resp.blob();
      } catch {
        return { ok: false, status: resp.status, ms, errorText: "Could not read mp3 body" };
      }
      return { ok: true, status: resp.status, ms, blob };
    }

    function playHowlFromUrl(url, { format = ["mp3"], volume = 1 } = {}) {
      return new Promise((resolve, reject) => {
        currentSound = new Howl({
          src: [url],
          format,
          volume,
          autoplay: true,
          onend: () => resolve(),
          onstop: () => resolve(),
          onloaderror: (_id, err) => reject(err ?? "loaderror"),
          onplayerror: (_id, err) => reject(err ?? "playerror"),
        });
      });
    }

    async function fetchTtsAudio({ endpoint, apiKey, model, voice, input, sessionId }) {
      const started = performance.now();
      const controller = new AbortController();
      currentRequest = controller;
      let response;

      try {
        response = await fetch(endpoint, {
          method: "POST",
          signal: controller.signal,
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ model, voice, input }),
        });
      } catch (e) {
        const ms = Math.round(performance.now() - started);
        if (sessionId !== playSession) return { aborted: true };
        return { ok: false, status: "fetch", ms, errorText: String(e?.message ?? e) };
      }

      const ms = Math.round(performance.now() - started);
      if (sessionId !== playSession) return { aborted: true };

      if (!response.ok) {
        let errText = "";
        try { errText = await response.text(); } catch {}
        return { ok: false, status: response.status, ms, errorText: errText || response.statusText };
      }

      let audioBlob;
      try {
        audioBlob = await response.blob();
      } catch {
        return { ok: false, status: response.status, ms, errorText: "Could not read audio body" };
      }
      return { ok: true, status: response.status, ms, audioBlob };
    }

    async function playScript(script) {
      const apiKey = els.apiKey.value.trim();
      const endpoint = els.endpoint.value.trim();
      const model = els.model.value;
      const voice = els.voice.value;
      const scriptInput = String(script ?? "").trim();

      if (!scriptInput) {
        setState("warn", "No script", "Type a script with optional <a> tokens.");
        return;
      }
      if (!endpoint) {
        setState("bad", "Missing endpoint");
        return;
      }
      if (!apiKey) {
        setState("bad", "Missing API key", "Add a key in the field above.");
        return;
      }

      // Stop any previous playback/request before starting a new one.
      stopPlayback({ abortRequest: true, revokeUrl: true, bumpSession: true });
      currentAudioBlob = null;
      updateDownloadButton();

      els.playFullBtn.disabled = true;
      els.playScriptBtn.disabled = true;
      els.stopBtn.disabled = false;
      setState("warn", "Playing script…", `model=${model}, voice=${voice}`);

      const sessionId = playSession;
      const parts = parseScript(scriptInput);
      if (!parts.length) {
        setState("warn", "Nothing to play");
        els.playFullBtn.disabled = false;
        els.playScriptBtn.disabled = false;
        els.stopBtn.disabled = true;
        return;
      }

      for (const part of parts) {
        if (sessionId !== playSession) return;

        if (part.type === "asset") {
          const url = resolveLetterUrl(part.token);
          if (!url) {
            setState("bad", "Invalid letter base URL");
            break;
          }

          const u = new URL(url);
          const entry = {
            kind: "asset",
            id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
            time: fmtTime(new Date()),
            method: "GET",
            path: u.pathname,
            assetName: part.token,
            note: u.href,
          };
          addLogRow(entry);
          stats.total += 1;
          updateStats();

          try {
            setState("ok", "Playing…", clampText(`<${part.token}>`, 80));
            const res = await fetchMp3Blob(url, { sessionId });
            if (res?.aborted) return;
            if (!res.ok) {
              // Some hosts block fetch() via CORS; Howler can often still play the URL.
              stats.lastMs = res.ms ?? null;
              updateStats();
              try {
                await playHowlFromUrl(url, { format: ["mp3"] });
                stats.ok += 1;
                updateStats();
                finalizeLogRow(entry.id, {
                  ok: true,
                  status: "played",
                  ms: null,
                  bytes: null,
                  errorText: "Played directly (not merged; fetch blocked/CORS).",
                });
                continue;
              } catch (e) {
                stats.err += 1;
                updateStats();
                finalizeLogRow(entry.id, { ok: false, status: res.status, ms: res.ms, errorText: res.errorText });
                setState("bad", "Letter fetch error", `${res.status}`.trim());
                break;
              }
            }

            const blob = res.blob;
            stats.ok += 1;
            stats.lastMs = res.ms ?? null;
            stats.bytes += blob.size || 0;
            updateStats();
            finalizeLogRow(entry.id, { ok: true, status: res.status, ms: res.ms, bytes: blob.size || 0 });

            const objUrl = URL.createObjectURL(blob);
            try {
              await playHowlFromUrl(objUrl, { format: ["mp3"] });
            } finally {
              try { URL.revokeObjectURL(objUrl); } catch {}
            }
          } catch (e) {
            stats.err += 1;
            updateStats();
            finalizeLogRow(entry.id, { ok: false, status: "asset", ms: null, errorText: String(e ?? "asset error") });
            setState("bad", "Letter audio error", String(e ?? ""));
            break;
          } finally {
            if (currentSound) {
              try { currentSound.unload(); } catch {}
              currentSound = null;
            }
          }
          continue;
        }

        // TTS chunk
        const chunk = String(part.text ?? "").trim();
        if (!chunk) continue;

        let endpointUrl;
        try {
          endpointUrl = new URL(endpoint);
        } catch {
          setState("bad", "Invalid endpoint URL");
          break;
        }

        const entry = {
          kind: "tts",
          id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
          time: fmtTime(new Date()),
          method: "POST",
          path: endpointUrl.pathname,
          model,
          voice,
          chars: chunk.length,
          note: clampText(chunk, 120),
        };
        addLogRow(entry);
        stats.total += 1;
        updateStats();

        setState("warn", "Requesting audio…", clampText(chunk, 80));
        const res = await fetchTtsAudio({ endpoint, apiKey, model, voice, input: chunk, sessionId });
        if (res?.aborted) return;

        stats.lastMs = res.ms ?? null;
        if (!res.ok) {
          stats.err += 1;
          updateStats();
          finalizeLogRow(entry.id, { ok: false, status: res.status, ms: res.ms, errorText: res.errorText });
          setState("bad", "TTS error", `${res.status}`.trim());
          break;
        }

        const audioBlob = res.audioBlob;
        stats.ok += 1;
        stats.bytes += audioBlob.size || 0;
        updateStats();
        finalizeLogRow(entry.id, { ok: true, status: res.status, ms: res.ms, bytes: audioBlob.size || 0 });

        const chunkUrl = URL.createObjectURL(audioBlob);

        try {
          await playHowlFromUrl(chunkUrl, { format: ["mp3"] });
          setState("ok", "Playing…", `${audioBlob.size || 0} bytes`);
        } catch (e) {
          setState("bad", "Audio play error", String(e ?? ""));
          break;
        } finally {
          if (currentSound) {
            try { currentSound.unload(); } catch {}
            currentSound = null;
          }
          try { URL.revokeObjectURL(chunkUrl); } catch {}
        }
      }

      if (sessionId === playSession) {
        setState("", "Idle");
        els.playFullBtn.disabled = false;
        els.playScriptBtn.disabled = false;
        els.stopBtn.disabled = true;
      }
    }

    async function speak(text) {
      const apiKey = els.apiKey.value.trim();
      const endpoint = els.endpoint.value.trim();
      const model = els.model.value;
      const voice = els.voice.value;

      if (!endpoint) {
        setState("bad", "Missing endpoint");
        return;
      }
      if (!apiKey) {
        setState("bad", "Missing API key", "Add a key in the field above.");
        return;
      }

      const input = String(text ?? "").trim();
      if (!input) {
        setState("warn", "No text", "Type something to speak.");
        return;
      }

      // Stop any previous playback/request before starting a new one.
      // Revoke the previous object URL since we're replacing the audio.
      stopPlayback({ abortRequest: true, revokeUrl: true, bumpSession: true });
      currentAudioBlob = null;
      updateDownloadButton();

      els.playFullBtn.disabled = true;
      els.playScriptBtn.disabled = true;
      els.stopBtn.disabled = false;
      setState("warn", "Requesting audio…", `model=${model}, voice=${voice}`);

      const sessionId = playSession;
      let url;
      try {
        url = new URL(endpoint);
      } catch {
        setState("bad", "Invalid endpoint URL");
        els.playFullBtn.disabled = false;
        els.playScriptBtn.disabled = false;
        els.stopBtn.disabled = true;
        return;
      }
      const entry = {
        kind: "tts",
        id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
        time: fmtTime(new Date()),
        method: "POST",
        path: url.pathname,
        model,
        voice,
        chars: input.length,
        note: clampText(input, 120),
      };
      addLogRow(entry);

      stats.total += 1;
      updateStats();

      const res = await fetchTtsAudio({ endpoint, apiKey, model, voice, input, sessionId });
      if (res?.aborted) return;

      const ms = res.ms ?? null;
      stats.lastMs = ms;

      if (!res.ok) {
        stats.err += 1;
        updateStats();
        finalizeLogRow(entry.id, { ok: false, status: res.status, ms, errorText: res.errorText });
        setState("bad", "TTS error", `${res.status}`.trim());
        els.playFullBtn.disabled = false;
        els.playScriptBtn.disabled = false;
        els.stopBtn.disabled = true;
        currentRequest = null;
        return;
      }

      const audioBlob = res.audioBlob;

      stats.ok += 1;
      stats.bytes += audioBlob.size || 0;
      updateStats();
      finalizeLogRow(entry.id, { ok: true, status: res.status, ms, bytes: audioBlob.size || 0 });

      currentAudioUrl = URL.createObjectURL(audioBlob);
      currentAudioBlob = audioBlob;
      setState("ok", "Playing…", `${audioBlob.size || 0} bytes`);
      updateDownloadButton();

      currentSound = new Howl({
        src: [currentAudioUrl],
        format: ["mp3"],
        autoplay: true,
        onplay: () => {
          els.playFullBtn.disabled = true;
          els.playScriptBtn.disabled = true;
          els.stopBtn.disabled = false;
        },
        onstop: () => {
          stopPlayback({ abortRequest: false, stopSound: false });
          setState("", "Stopped");
          els.playFullBtn.disabled = false;
          els.playScriptBtn.disabled = false;
          els.stopBtn.disabled = true;
        },
        onend: () => {
          stopPlayback({ abortRequest: false, stopSound: false });
          setState("", "Idle");
          els.playFullBtn.disabled = false;
          els.playScriptBtn.disabled = false;
          els.stopBtn.disabled = true;
        },
        onloaderror: (_id, err) => {
          stopPlayback({ abortRequest: false, stopSound: false });
          setState("bad", "Audio load error", String(err ?? ""));
          els.playFullBtn.disabled = false;
          els.playScriptBtn.disabled = false;
          els.stopBtn.disabled = true;
        },
        onplayerror: (_id, err) => {
          stopPlayback({ abortRequest: false, stopSound: false });
          setState("bad", "Audio play error", String(err ?? ""));
          els.playFullBtn.disabled = false;
          els.playScriptBtn.disabled = false;
          els.stopBtn.disabled = true;
        },
      });

      currentRequest = null;
    }

    function syncCharCount() {
      els.charCount.textContent = String((els.memoText.value || "").length);
    }

    function loadRememberedKey() {
      const remembered = localStorage.getItem(LS_KEY_REMEMBER);
      const isOn = remembered === "on";
      els.rememberKey.value = isOn ? "on" : "off";
      if (isOn) {
        const v = localStorage.getItem(LS_KEY_APIKEY);
        if (v) els.apiKey.value = v;
      }
    }

    els.playFullBtn.addEventListener("click", () => speak(normalizeForTtsOnly(els.memoText.value)));
    els.playScriptBtn.addEventListener("click", () => playScript(els.memoText.value));
    els.stopBtn.addEventListener("click", () => {
      stopPlayback({ abortRequest: true, bumpSession: true });
      setState("", "Stopped");
      els.playFullBtn.disabled = false;
      els.playScriptBtn.disabled = false;
      els.stopBtn.disabled = true;
    });
    els.downloadBtn.addEventListener("click", () => {
      if (!currentAudioBlob) return;
      downloadBlob(currentAudioBlob, makeTimestampedName("tts", "mp3"));
    });
    els.clearLogBtn.addEventListener("click", () => {
      stopPlayback({ abortRequest: true, revokeUrl: true, bumpSession: true });
      els.logBody.innerHTML = "";
      logRowsById.clear();
      stats.total = 0;
      stats.ok = 0;
      stats.err = 0;
      stats.bytes = 0;
      stats.lastMs = null;
      updateStats();
      setState("", "Idle");
      currentAudioBlob = null;
      updateDownloadButton();
      els.playFullBtn.disabled = false;
      els.playScriptBtn.disabled = false;
      els.stopBtn.disabled = true;
    });

    els.memoText.addEventListener("input", syncCharCount);
    els.rememberKey.addEventListener("change", () => {
      localStorage.setItem(LS_KEY_REMEMBER, els.rememberKey.value);
      if (els.rememberKey.value !== "on") {
        localStorage.removeItem(LS_KEY_APIKEY);
      } else if (els.apiKey.value.trim()) {
        localStorage.setItem(LS_KEY_APIKEY, els.apiKey.value.trim());
      }
    });
    els.apiKey.addEventListener("input", () => {
      if (els.rememberKey.value === "on") {
        const v = els.apiKey.value.trim();
        if (v) localStorage.setItem(LS_KEY_APIKEY, v);
      }
    });

    document.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        speak(normalizeForTtsOnly(els.memoText.value));
      }
      if (e.key === "Escape") {
        stopPlayback({ abortRequest: true, bumpSession: true });
        setState("", "Stopped");
        els.playFullBtn.disabled = false;
        els.playScriptBtn.disabled = false;
        els.stopBtn.disabled = true;
      }
    });

    syncCharCount();
    loadRememberedKey();
    updateStats();
    updateDownloadButton();
    setState("", "Idle", "Ctrl/⌘ + Enter plays full text, Esc to stop.");
  </script>

</body>
</html>
